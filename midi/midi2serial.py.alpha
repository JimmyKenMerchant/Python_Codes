#!/usr/bin/python3

# Author: Kenta Ishii
# SPDX short identifier: BSD-3-Clause
# ./midi2serial.py /dev/serial0 115200 0.01

import sys
import serial
import jack
import binascii
import signal

__name = "JACK Audio Connection Kit to Serial Interface Bridge"
__version = "1.0.0"
version_info = __name + " " + __version
prompt = "\n**Press Enter to Quit**"

print (sys.version)
argv = sys.argv

# Set MIDI Channel for Psuedo Polyphonic Device (Sends MIDI Message to Inactive Monophonic Device)
if len(argv) >= 5:
    monotone_midichannel = int(argv[4]) - 1
else:
    monotone_midichannel = None # None Type

# Set Number of Monophonic Devices for Pseudo Polyphonic Device
# If Baud Rate Is 115200, I Recommend that you apply up to 3 devices
# because 115200 includes 3 times as many as 31250, MIDI Baud Rate.
if len(argv) >= 6:
    monotone_number = int(argv[5])
    # Make Table to Check Active/Inactive Monophonic Devices and Current Tone Number
    monotone_devices = []
    for i in range(0, monotone_number, 1):
        monotone_devices.append(0x80) # Tone Number Is Up to 127 (0x7F)
else:
    monotone_number = None # None Type

# Set UART Connection
try:
    uart = serial.Serial(port = argv[1], baudrate = int(argv[2]), timeout = float(argv[3]))
except serial.SerialException as e:
    print(version_info + ": Error on UART Settings")
    sys.exit(1)

# Set MIDI Connection and Callback
midiclient = jack.Client("MIDI-TO-SERIAL")
midiport = midiclient.midi_inports.register("input")

@midiclient.set_process_callback
def process(frames):
    for offset, data in midiport.incoming_midi_events():
        data = binascii.hexlify(data) # Buffer Object (Binary) to String of Ascii Characters
        bytes = [] # Empty List
        for i in range(0, len(data) >> 1, 1): # If 3 bytes, len(data) will be 6. Divided By 2 through Logical Shift Right.
            # data[start(inclusively):end(exclusively)], String to 8-bit Binary
            start = i << 1  # 0,2,4,6... Multiplied By 2 through Logical Shift Left.
            end = start + 2 # 2,4,6,8...
            bytes.append(int(data[start:end], 16))

        #print(offset, end="\n")
        #print(data, end="\n")
        #print(bytes, end="\n")
        for count, byte_int in enumerate(bytes):
            if byte_int >= 0x80: # If Status Byte
                if monotone_midichannel is not None:
                    midichannel = byte_int & 0xF # Only Bit[3:0], 0 to 15
                    if monotone_midichannel == midichannel:
                        midistatus = byte_int >> 4 # Only Bit[7:4], 8 to 15
                        if midistatus <= 8: # If Note On
                            for i in range(0, len(monotone_devices), 1): # If 3 bytes, len(data) will be 6. Divided By 2 through Logical Shift Right.
                                if monotone_devices[i] >= 0x80:
                                    byte_int = byte_int + i + 1
                                    monotone_devices[i] = bytes[count + 1]
                        elif midistatus <= 10: # If Note Off / Polyphonic Key Pressure
                            for i in range(0, len(monotone_devices), 1): # If 3 bytes, len(data) will be 6. Divided By 2 through Logical Shift Right.
                                if monotone_devices[i] == bytes[count + 1]:
                                    byte_int = byte_int + i + 1
                                    if midistatus == 9: # If Note Off
                                        monotone_devices[i] = 0x80
                        else:
                            for i in range(0, monotone_number, 1):
                                for byte_int2 in tuple(bytes): # Make Constant List from Dynamic List
                                    if byte_int2 >= 0x80: # If Status Byte
                                        bytes.append(byte_int2 + i + 1)
                                    else: # If Data Byte
                                        bytes.append(byte_int2)

            byte = byte_int.to_bytes(1, "little")
            uart.write(byte)
            print(count)
            print(byte)

# Set Keyboard Interrupt
def handle_sigint(signum, frame):
    print(version_info + ": Force Stop")
    uart.close()
    sys.exit(0)

signal.signal(signal.SIGINT, handle_sigint)

# Activate MIDI Client by "with" Syntax
#midiclient.activate()
#midiclient.deactivate()
#midiclient.close()
with midiclient:
    print(version_info + prompt)
    input()
    uart.close()
